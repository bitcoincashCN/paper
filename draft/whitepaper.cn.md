Hacash：一种大规模支付实时结算的加密货币系统（稿）--gotolab批注版
===

【摘要】
---

* gotolab：我将对本文进行整体批注，指出本文中：
* 1、创新及特点
* 2、哪些内容是跟比特币完全重叠的
* 3、哪些内容认为对比特币进行改进，但实际上没有意义或不重要
* 4、哪些内容错误判断了比特币的优势，将之视为劣势

本文提出了一种运用通道链有序多签名实时冲销结算方法，可无上限扩充每秒交易量，能掠夺性惩罚不诚实一方从而确保资金安全和实时到账的加密电子货币发行支付及金融体系。内建复合签名地址和层级股权控制地址、多方签署交易结构、全类别支付协议及资产变更协议，满足现代金融、企业及个人的绝大部分支付需求。结合工作量证明、历史见证及分叉投票的抢占式记账权奖励分配方式，能有效规避双重支付、防范算力攻击和降低马太效应。并采取符合经济规律的货币发行、公账及通道手续费、通道利息和区块钻石等激励机制，无需信任委托于任何机构即可维持整个系统长期有效运行。

* gotolab：实时到账、无上限扩充TPS，这是最大的特色（区别于比特币）。
* “掠夺性惩罚”其实已经包含在比特币的追随最长链原则中。
* 复合签名与比特币的多重签名有何区别？工作量证明、抢占式几张券奖励分配方式、防双重支付、手续费、无需信任任何机构这些都是比特币的基本特征。

通道链结算网络的基本原理是：每两个账户各自锁定若干资金，组成一个支付通道，私下可双方签名多次支付，期间无需向全网广播确认交易，只需最后一次向主网提交最终的余额分配即可取回各自正确拥有的资金，从而极大地自由扩充整个系统的每秒交易数量；如果单方结束通道，则其资金会被锁定一段时间，如果另一方在此期间内向主网举证更新的余额分配而证实对方作假，则揭露方将会夺取对方全部资金，从而迫使双方保持诚实；只需将多个支付通道连接起来，并从收款方开始让所有资金流转方有序签名直至付款者最后签署，则所有相关方都将同时收到和支出钱款，从而确保支付完整、实时到账和资金安全；通道可收取微量手续费激励其提供稳定服务。

* gotolab：通道结算网络，也就是链下的结算模式，最后真实上链结算。这种模式听起来跟比特币的“闪电网络”要实现的效果是一样的。
* 通道的惩罚和仲裁机制可能跟闪电网络也是类似的（待验证）。

目录
---

一、前言
  1. 危机
  2. 货币的未来
  3. 我们需要什么

二、基本原理
  1. 技术理论
  2. 自利原则
  3. 不足

三、通道链结算网络
  1. 基本假设
  2. 主要原理
  3. 技术实现
  4. 通道关闭
  5. 仲裁保护
  6. 收付平账
  7. 反集中化
  8. 快速通道
  9. 资金计算

四、交易
  1. 基本数据结构
  2. 复合签名地址
  3. 层级股权控制地址
  4. 多方签署
  5. 支付类别
  6. 签名剥离
  7. 手续费
  8. 字段格式
  
五、激励
  1. 记账权竞争奖励
  2. 公账手续费
  3. 通道服务费
  4. 通道利息
  5. 区块钻石
  6. 数据服务

六、货币
  1. 总量及增长
  2. 无限分割
  3. 单位及符号
  4. 禁止人为货币政策

七、隐私
  1. 匿名
  2. 支付混搅
  3. 前置延期兑付
  4. 加密结算网
  5. 通道冲销

八、风险与防范
  1. 通道链延迟签名攻击
  2. 低成本通道欺诈
  3. 通道信用货币创造及违约
  4. 算力集中化、51%攻击和游击挖矿
  5. 价格极端波动
  
九、技术设计原则
  1. 简单直观
  2. 数据紧凑、执行高效
  3. 公账数据规模可控
  4. 数据剥离及压缩

十、结论

【附录】
  1. 参考引用
  2. 区块数据结构定义示例及注释
  3. 部分算法代码


---

第一章、前言
---

### 1. 危机

我们走到了货币体系变革的时代关口。

纵观历史，文明发展和经济进步总伴随一个前提：文化和金融自由。无论资本主义还是社会主义，无论发达国家还是发展中国家，周期性出现的经济危机却让人们对金融体系施行更加严厉管制的呼声越来越高。究其本源，不同的现代社会经济体制都有一个共同点：强制性主权信用货币和银行部分准备金制度。这本质上是一种欺诈，是金融不稳定的根源，是除暴力掠夺之外导致利益分配不公的最大缘由。随之必然而来的经济干预政策极尽推波助澜或矫枉过正，如同王朝更迭一样反复伤害本该渐进增长的经济体和人们的生活水平。

不稳定、不可预期、人为肆意干预和操控的金融环境，将使得大型资本在根本不必进入实体经济的情况下即可轻松获得超额增值。当资本特别是巨型资本的回报率超过甚至远超长期整体经济发展的平均回报水平时，贫富差距就会不可避免的地加速拉大，直至社会矛盾加剧、经济危机和动乱。如果某一代人刚好在长达十年甚至二十年的大萧条起始时成年，那么他们的命运将注定艰难困苦、碌碌无为。为了抹平这种周期性危机导致的严重代际不公（或许因此带来更严重的社会动乱、革命甚至战争），采取经济干预和刺激政策，注入兴奋剂成了一个痛苦的权宜之计。不过，面对不利的人口与债务趋势，不可能通过短期的刺激手段应对长期的结构性危机，这根本就是在自欺欺人。

对银行和大型企业的财政救助和货币流动性刺激其本质上是劫贫济富，是把成本和损失社会化，是让全体民众为一小部分人的贪婪和肆意妄为买单。我们需要能够从根本上解决问题，避免或大幅减少金融危机和经济崩溃，从而保卫金融弱势群体的利益不被裹挟和榨取。

中国北宋时由于政府在四川地区强制使用铁质钱币造成的笨重不便，民间出现了原始的纸币：交子。这似乎是一种货币金融的“进步”。当时的政权发现这简直是完美的税收工具，随即将纸币发行权收归国有。不用再耗费大量财力物力丈量土地、清点户籍、收钱造册，只需轻轻开动印刷机，就能源源不断悄无声息地从民间抽取大量财富。但随之而来的反复超级通货膨胀和经济崩溃打破了王朝的如意算盘，终于在明朝初年间人们彻底不再相信任何纸片，退回到了贵金属货币时代，甚至大家直接通过分割和称重散碎白银来进行交易。这种看起来像原始退化的货币状态却给了民间极大的金融和经济自由度，成就了中国历史上少有的金融稳定时期，普通百姓生活水平得到提升，这种情况一直持续到清朝后期。

货币来源于市场，并终将服务于市场。其形态本身并没有高低之分，其本质也无绝对的好与坏，只有是否更加适应及高效。我们需要一个自由竞争、适者生存的货币市场和开放透明、避免欺诈的金融环境。这个世界上的不公本质上是信息的不公，是金融的不公，解决这个问题的答案是大力发展开放金融，以开放实时审计破除任何准入限制。

* gotolab：说得对，奥地利学派的理论。比特币也是这样说的。

### 2. 货币的未来

黄金本是地球上最适合作为货币的物品，但是人们现在却并没有使用它进行大规模的交易支付。主要原因有：1. 笨重不便于携带；2. 不可无限分割用于小额支付；3. 长期流通造成磨损耗费；4. 造假掺假技术越发强大。在欧洲历史上曾长期使用黄金作为储备的纸币进行流通，这种方式表面上兼具黄金的优点却规避了其作为日常支付手段的缺陷。只不过，没有任何个人和组织禁得住凭空创造钱的诱惑，无论承诺多么坚决，纸币总是会被超发。与历史上在金、银、铜币里掺杂其他金属故意造成贬值的情况别无二致，甚至由于发行成本的极度降低造成严重通货膨胀从而导致经济的崩溃。这种情况曾反复多次出现。

阻止黄金作为通用支付手段的另外两大具备争议的问题是：1. 储量位置分布不均，地下有金矿的国家相当于坐收全世界的铸币税；2. 无法在经济的增长率和规模大幅变动之时快速调节供应量，容易造成紧缩和钱荒。特别是关于第2点的争论已大量见于奥地利、现代货币和凯恩斯等各个经济学派的著作之中，其中一些认为信用扩张是经济危机的根源、是洪水猛兽，而另一些则坚定认为没有“弹性”的货币将会锁死整个经济的发展。

历史上，货币大致经历了如下几个种类或阶段（并不代表严格分类、出现的先后顺序或本质优劣）：

	1. 通用价值物（谷物、布帛、牛羊、香烟等）
	2. 稀有稳态物（金、银、铜、宝石、贝壳等）
	3. 信托账务凭证（存款证明、债务凭证、匿名支票、商品券、纸黄金等）
	4. 主权信用符号（法币）

其中第1、2阶段由于无法满足现代商业支付需要而被逐渐淘汰，第3阶段似乎会造成信用膨胀和银行家欺诈带来的经济脆弱及崩溃，人们随即期望政府设立的央行体系解决问题，于是走入了第4个阶段，但效果如大家所见。

我们认为，货币的未来，也就是第5阶段的形态将会是「公认规则」为主体、骨干，「个体信用」为分支、补充的开放性电子网络体系，并且会在自由竞争的过程中持续改进和显现出最优的系统。这种「公认规则」不以任何人的意志为转移，不受强势利益集团的控制，就像没有人能够凭空创造黄金一样。公平的规则能让全世界有效的参与进来。货币远不止是一般等价物或会计单位，它更是一种信号，是经济运转的信息系统。我们可以忍受和修复局部信用失效，但绝对无法承担整体信用崩塌的后果。

2008年，比特币（Bitcoin）以及背后区块链技术的出现和十年来的有效运转为我们指明了方向。

* gotolab：对的，这就是比特币。

### 3. 我们需要什么

区块链的核心价值并不在去中心化，也不在永久保存数据，更不在逃避监管，而是在于去信任化。

比特币的出现并不是为了提升局部暂时支付效率或者减少部分瞬时交易成本，而是为了避免或降低辜负我们信任的企业与机构作恶的后果。它的愿景是完全匿名与去中心点对点信任，而区块链的未来则是公开透明与分布式自审计信任，是通过消耗廉价算力资源来换取社会整体交易成本的降低和协商效率的提升。

正如互联网满足了人类信息通讯的基础需要一样，区块链是为了解决困扰人类几十万年的大问题：欺诈。我们历史上为此付出了巨大成本，消耗了无数资源，阻断了太多交易。所以我们不能在未来的货币体系中加入任何欺诈的可能性，上帝保证也不行。

我们需要一种货币和随之而来的金融体系，一种信任最小化的货币系统，没有人能肆意降低它的成色，也不用耗费过多信任成本，可以更好的维护经济系统的稳定发展，并且完全能满足现代商业支付、企业财账及金融清算的需要。

* gotolab：不看上下文，说的就是比特币。

第二章、基本原理
---

### 1. 技术理论

货币需要相对的稀有排他性以履行其价值信号的功能，没有人会把水、土壤或者树叶作为交易媒介。然而在电子信息世界里，一切都几乎可无成本复制。那么以二进制数据为载体的货币就有着一个致命的本质缺陷：数量无限且真假难辨。如果我们仍然依赖一个在线发行机构或电子造币厂确保钱币的真实有效和数量上限，那么从历史经验来看，没有谁能忍受凭空创造钱的诱惑，最终大家手里的东西将会一文不值。

一种直观就能想到的解决方案是将每一枚电子货币都编上整数号码，并公布一个号码的上限（或者这个上限每年自动增长固定数额），然后用电子签名的方式标注上每一枚货币的拥有者（先忽略谁最先拥有这些货币的问题），然后每一枚货币在支付的同时，都将由当前拥有者用私钥签名接收者的公钥，表明此枚钱币已经支付给对方，并保留所有历史支付记录。如此则解决了电子货币复制造假和数量无限的问题。

但是上文提出的方案有几个显而易见的缺陷：

    1. 不能被分割用作小额支付或找零；
    2. 同一枚钱币可被同一时间支付给不同的两个人甚至更多人（双花）；

缺陷1可以用足够小额的面值（编号上限足够大）来暂时缓解。而双花问题则比较麻烦，一种办法是让一个公共的中心数据库来保存及证明每一笔支付的记录，但却仍然依赖机构负责人的正直诚信，有被欺诈的可能。另一种办法是通过广播，让所有人都各自拥有一份账本，列出所有人每一笔支付的记录，当接收钱币时即在自己的账本上查询钱币的拥有者，以此避免双花。

每个人都有一份账本的方案看似解决了双花问题，但仍然具备很大的缺陷：

    1. 维护一套账本不间断记录所有支付是需要耗费很大成本的，不经常收到钱币的个人实时维护一整套账本显然得不偿失。最后大家还是会依赖一些大的类似银行的机构出具的账本。
    2. 当有一些支付因为广播的技术原因并未到达所有账本记录者（比如海底光缆被切断），大家各自的账本记录就会不一致。长时间便会形成大量的不同版本，大家彼此不相认同，最终支付体系崩溃。
    3. 如果每个人花费很大成本维护账本只是为了自己在收钱时查询有效性，那么这种货币系统未免太过低效，并且最终会因为搭便车问题导致账本无人维护。

当然，还有一个最为关键的问题：谁应该最先拥有这些电子货币？

gotolab：比特币事实上解决这些问题，运行得很好。

### 2. 自利原则

长期来看，任何单方面寄希望于对方的正直诚实和信守承诺，而没有其他激励和制衡的合作体系，终将不可持续。

不断地有效运转的社会合作系统，无一不是正确面对人性的贪婪和自利，并加以利用让其用于维护体系的自我运行。比特币走在了正确的道路上，并在为期十年的发展中越发壮大。它通过创造性地将账本记录和货币发行两者结合起来，为大家维护账本提供了充足的动机，并采取工作量证明竞争记账权的方式让所有人的账本始终保持统一，从而巧妙的解决了上文所面临缺陷。当然它也并没有使用为每一枚钱币编码的体系，而采用了未花费余额（UTXO）的方式支持小额支付和找零。关于比特币的详细理论这里并不过多介绍，大家请参阅中本聪的论文。

* gotolab：建议将比特币有关的内容可删可减。

### 3. 不足

天下没有免费的午餐。正如我们上文一直以来的“提出问题-解决问题-遇到新问题”的推导一样，公开竞争记账的货币体系仍然有两个大家所诟病的缺点：

    1. 通过哈希算法重复运算竞争一定时间内的账目记录权从而获得增发的货币奖励的方式耗费了大量的硬件及能源。
    2. 由于需要向所有账本记录人广播每一笔支付并得到确认，导致总体支付效率非常低下（大约每秒7笔），也导致需要支付高昂的手续费，根本无法满足现代商业的需要。

严格来说，我们并不认为第1点是真正的缺点。除了短期内的投机和非理性繁荣，在一个没有强制的自由竞争领域，大家总会找到一个成本和收益的平衡点，我们使用了大量能源和精力，并不是因为我们疯了，而是这样做总体上有利可图，耗费的成本终将在其它方面更多的补偿回来。正如我们并没有用尽全力把地球上所有的石油和黄金全部都开采出来一样，因为这么做不经济。

* gotolab：第1点确实并非“缺点”。第二点，通过分层方式解决是可行的。不一定要“垂直集成”。

认为一个货币系统应该尽可能少消耗能源的想法非常朴素原始，古人也有一个类似的疑问和偏见：商人只是把物品从一个地方搬到了另一个地方，并没有创造任何东西，那么他们凭什么赚这么多钱？

关于消耗能源（其他任何形式的资源）和避免受害这两者之间，只能做一个权衡：

    1. 大家平时不必付出任何成本即可享受免费、方便的好处，代价是提供服务的中心机构可能被攻破利用，或者在暗处损害大家的利益。
    2. 平时付出一定的成本（费用或精力），避免了有人或组织欺诈自己的风险。
    
如果有人宣称同时实现了以上两点（既完全免费又绝对安全），要么没能认识到问题的本质，要么就是不怀好心。

* gotolab：对的。至少目前我们还没有发明这种技术。在此之前，可以先让比特币标准运行一百年，覆盖10亿人再说。

可暂时延缓第2个缺点最直观的办法是扩容，即扩充区块大小上限或减少区块生成间隔时间，但这无法从根本上解决问题。区块大小具备理论上限，数量太大会延长下载传输同步的时间，这进一步限制了区块间隔时间的上限。这是一个水涨船高的过程，新的交易总会填满扩充的空间，而全世界的交易支付量远大于当前受硬件体系制约的扩容理论上限。另一方面，数据量扩大到一定程度，也会导致普通个人计算机无法装下完整的账本，最终淘汰绝大部分参与者，数据向财力雄厚的某些大机构聚拢。

另一种某些改进者正在尝试的方案是：极度缩减账本记录者的总数量（比如21个或101个），对他们的工具性能提出比较高的要求，并将新增钱币给予他们以资鼓励，整个系统便能承载很大的交易量。这看起来令人欢欣鼓舞，然而如前文所说，这种形式有它不可避免的缺点，其本质与历史上的铸币厂分局体系无太多区别。

也有一些人希望通过容忍临时的数据不一致性，换来整体系统吞吐量的极大提升（广义的DAG结构），这只能应用于对数据真实性要求不严格或无需立等验证的场景，在一个小额即时支付系统里是完全不可靠的。

也许是不认为这是个麻烦，也许是暂时没考虑清楚而刻意略过，中本聪没有在论文中指明如何承载巨大交易量的解决方案。

* gotolab：同意，PoS/DPoS扩容吞吐量，但却损失了“货币”的基本要素（安全）。


第三章、通道链结算网络
---

### 1. 基本假设

参照显示世界的运转，成年健壮男子可轻松抢夺街上妇女儿童的财货占为己有，可多数人并没有这么做，是因为大家知道，背后的警察和法律体系将让其付出更大的代价，从而让这种作恶行为得不偿失。事实证明，就算存在风险，只要具备严格的惩罚机制，大家的理性驱利行为将维持系统总体有效运行。

我们提出，公共账本不应该包含全部的交易支付记录，而应该作为一个严格准确有效且不能被操控的仲裁体系和最终清算系统，保证在私下进行的支付行为不能欺诈，否则即给予严厉的惩罚，在无限次数重复对等博弈中，大家会倾向于保持诚实来长期合作。这种体系有着极大的伸展能力，可动态按需增加交易量，并在理论上没有上限，从而能完全应对现代商业发展的需要。

* gotolab：逻辑没毛病。

### 2. 主要原理

我们需要实现一个能实时到账、没有任何人会丢失资金的小额高频支付系统，可用于网络商城或实体商店中的购买行为。如果有中间人提供资金服务，那么所有人都应该同时保证收支的正确。要点在于，资金链条的结算应该是实时同步而不能为异步，否则将带来严重的中心化和资金安全问题。

首先，我们需要创建一系列的双向结算通道，他们分别是顾客和资金通道服务者（简称节点）、商家和节点，必要时顾客和商家可直接建立结算通道。发起支付时，由商家或服务商家的节点查询资金通道链条的路由，并建立整个链条的TCP连接，然后从所有节点处取得所有的通道ID、上一笔交易hash、交易序号、余额确认等信息后，建立一个完整的交易，并发送给所有参与方。接着从商家开始，按顺序，所有人将自己对这笔支付交易的签名发送给所有其他方，直到顾客的签名都被大家收到，此时商家签署交易确认的消息，从链条尾端依次关闭所有TCP连接。最终所有相关放都同时收到（和支出）了资金，支付交易完成。每个通道可收取微量的服务手续费用，以激励节点提供稳定的服务。

* gotolab：逻辑没毛病。

### 3. 技术实现

下文描述了所有的技术细节以及每一步完成后的数据状态。

* gotolab：后发优势的期限是多少？这要求在这个期限之内用户必须在线。应该添加仲裁者服务器（用户离线前把数据传给仲裁者，要求其代理仲裁）
* 以下技术实现不做批注，全部删除。



第四章、交易
---

### 1. 基本数据结构

为了保证系统运行的效率，交易的数据结构设计应该尽量简单和紧凑（stupid simple but efficient work），并让人类与机器都容易理解。（金融规则的人类可读性的重要将在`设计原则`一章讨论）

总体上可分为以下三个层级:

    区块(Blocks) >> 交易、事务(Transactions) >> 功能、资产(Actions)

以 json 格式示例：

```js
{
  version: 0, // 区块版本号
  height: 0,  // 区块高度
  timestamp: 0, // 区块时间戳

  prevHash: Buffer.alloc(32), // 前一个区块的 hash
  mrklRoot: Buffer.alloc(32), // 所有交易的梅克尔树根
  
  /* other extend field ... */

  transactions: [ // 区块包含的所有交易
    {
      type: 1, // // 交易类型
      timestamp: 12313423, // 交易时间戳
      address: "xxxxxxxxxxxxxxxxxx" // 交易的默认主地址（手续费支出地址）
      fee: { // 交易确认手续费
        unit: 248, // 手续费单位
        amount: 1234, // 手续费数
      },
      actions: [ // 交易的具体资产对象  或执行的动作
        {
          kind: 1, // 资产或动作类型（1 表示转账）
          bill: { // 转账总数量
            dist: 2, // 精度空间
            amount: new Buffer(), // 数额
            unit: 248, // 单位
          },
          address: "ooooooooooooooooo", // 转出地址
        }
      ],
      signs: [ // 签名
        {
          publicKey: Buffer.alloc(32), // 公钥
          signature: Buffer.alloc(64), // 签名值
        }
      ],
      multisigns: [ // 复合签名
        {
          publicKeyScript: Buffer.alloc(32, 96), // 公钥脚本
          signatureScript: Buffer.alloc(64, 192), // 签名结果脚本
        }
      ],
    },
  ],

}
```

可以看到，一笔交易大致分为 `actions` 、`signs` 和 `multisigns` 三个部分。为何不采用智能合约等更加灵活和“先进”的交易结构，我们将在`第九章`进行讨论。

* gotolab：跟比特币没差别。

### 2. 复合签名地址

单一签名地址有秘钥丢失、被盗的风险，并且无法满足共同托管资金的需求。我们需要一种能让两个或三个私钥，以不同的权限配置来管理资金的功能，例如：

    1. 甲和乙共同存款，需要两个人都提供签名才能取出资金
    2. 夫妻联名账户，两人任意一个都能从共同账户支出
    3. 交易所、在线钱包、离线私钥三者需要至少两方才能转出资金，以应对被盗和丢失的风险

交易结构中的 `multisigns` 复合名即支持二、三个私钥组成一个复合地址，那么可选的管理权限模式分别为 `1/2`、`2/2`、`1/3`、`2/3`、`3/3` 五种。以此类推，复合签名地址最多可支持200个私钥管理一个复合地址。

复合地址不存在保密的私钥，而有多个公钥拼合成一段数据，并由此计算生成一个公开的私钥。每次交易都需要提供这个拼合的公钥作为基础脚本，然后提供一个签名数据的拼合列表以供验证。

* gotolab：跟比特币没差别。

### 3. 层级股权控制账户

复合签名地址已经很好的解决了秘钥丢失、被盗安全和简单共同托管的需求，但面对复杂的经营结构（主要是受益权和投票权），我们需要一个能支持现代企业股权结构的账户体系。

此种账户必须满足以下特征：

    1. 可由若干个私钥共同管理，避免安全性问题
    2. 可更换（增、删、改）管理私钥，但地址固定不变
    3. 一个可更改的投票生效比例
    4. 支持同股不同权
    5. 极端情况下避免丢失资金
    
* gotolab：这是“通证”技术。使用支持智能合约的侧链实现即可，不用重复造一个以太坊轮子。

#### 1) 构建

由于以上特点，我们需要在主网上保存和管理账户。开启一个股权账户的交易类似于：

```js
{
    // 1~10000 满足票数有效比例（万分比）（必须等于或大于此万分比值即可操作账户）
    validRightsRatio: 6666,
    // 组成列表
    forms: [ // 数量 200 个以内
      // 投票权 和 受益权 可以不等比（即同股不同权）
      {
          address: '19aqbMhiK6F2s53gNp2ghoT4EezFFPpXuM',
          //   4 byte, 0~4294967295, 权益数
          rights: 1,
          //   4 byte, 0~4294967295, 投票权
          votes: 3,
      },
      {
          // 成员可以为复合地址
          address: '29aqbMhiK6F2s53gNp2ghoT4EezFFPpXuM',
          rights: 3,
          votes: 5,
      },
      {
          // 成员也可以为其他股权账户
          address: '39aqbMhiK6F2s53gNp2ghoT4EezFFPpXuM',
          rights: 2,
          votes: 3,
      },
    ]
}
```

主网确认这笔交易后，会在数据库能用`forms`提供的成员地址，加上交易时间戳，组成一段数据并由此生成私钥和公钥，作为新创建的股权账户。

股权账户的成员可以为普通地址、复合地址，也可以为其它股权账户，并指明相应的投票权和受益权。主网将会在数据库内储存所有的地址控制结构，每一个地址都有一个控制树。

#### 2) 验证

检查一笔股权账户发起（或参与）的交易是否有效，需要从数据库内读取控制树，并从签名列表内检验是否具备足够票数的成员签名。在票数足够的情况下，可忽略后续的签名检查。

一个股权账户可能由其它多个股权账户控制，而上层的股权账户又包含更上层的股权账户成员，类似现实中公司之间的多层投资关系。如此一来一笔大型地址的交易甚至需要验证上百个签名，这将消耗很大的数据空间并拖慢交易确认速度。我们采取按交易数据空间大小来计算交易费用的方式可一定程度阻止超大股权账户的频繁交易。实际上，日常的普通支付大可授权给专门的财务账号，而需要股权账户签名的交易仅仅为类似重大行业投资这样极低频率的交易。

#### 3) 管理

股权账户在主网注册后，可增删管理成员和更改权益。需要满足投票数的成员签署一笔更改交易即可完成。类似的，也可以更改生效票数比例。

成员及权益的可任意更改，股权账户的地址则保持不变。

#### 4) 账户最低金

股权控制地址将占去很大的数据空间和验证时间，是非常珍贵的资源。为了避免浪费，在注册和增加（更改与减少除外）管理成员时，除了让交易验证者收取普通的交易确认手续费之外，还需要在账户内锁定与手续费相同的金额，作为账户的维护金。

在地址注册之前，需要先向待注册的股权账户内发送一定量的资金，用于确保账户最低金足额，才能完成注册。（在账户正式向主网注册之前，先在本地计算生成目标地址，并在主网向其转账）

#### 5) 注销

为了避免状态数据库空间的膨胀和浪费，股权账户支持注销（删除对应的成员列表和控制树）。账户最低金在注销地址时返还给指定的其他账户。

#### 5) 资金安全

考虑到可能由不可抗力导致的集体性私钥丢失，以至于无法凑足达到生效票数的签名数量，从而无法进行任何交易操作，组织的资金实际上永远丢失了。并且受益权较大而投票权较小的成员将蒙受更加严重的损失。我们需要在这种极端情况下能够将资金安全提取出来。

设计成可以由股权账户控制树中任意一个上层成员地址发起资金保护模式，发起的条件为自己账户需要锁定相比股权账户1%数额的资金，锁定期为半年。半年内如果有其他成员地址提起解除，或者股权账户相关私钥已经找回并发起一笔交易，则自动退出资金保护模式。

半年后，提起保护模式的账户可将股权账户内的资金，通过发起另外一笔交易提取到自己的账户内，从而避免极端情况的资金永久丢失。

### 4. 多方签署

设想一种股权投资的场景：一家公司（简称A方）接受出资者（简称B方）一万个单位的资金投入，出让20%的股权。此种情况下，A和B任何一方先行操作，都有被欺诈的风险：A先出让股份则B不注资，B先转账注资则A可能反悔而不出让股份。

我们需要一笔交易能同时完成注资和分股两个操作，其中任意一个操作失败，而另一个则也自动失败。这时就需要双方对一笔交易进行联合签署：

```js
{
    type: 1, // 交易类型
    timestamp: 23423442, // 交易发起时间
    // 交易资产、动作
    actions: [
        {
            kind: 6, // from 给 to 转账
            from: 'xxxxxxxxxxxx', // address
            to: 'ooooooooooo', // address
            bill: { // 转账金额
                dict: 1,
                amount: 10000, // 数额
                unit: 248, // 单位
            }
        },
        {
          kind: 7, // 新增股权管理成员
          forms: [
              {
                  address: '19aqbMhiK6F2s53gNp2ghoT4EezFFPpXuM',
                  rights: 3, // 收益权
                  votes: 3, // 投票数
              },
          ]
        }
    ]
}
```
此交易包含两个`action`，双方都签名后，将同时完成资金的转移和股权的分配。

但上述交易仍然有一个漏洞：如果公司在上述交易签名完成但未确认生效的期间内，抢先广播一条交易，将原先的股权增发一百倍给原来的股东，则这笔交易确认成功后，新的出资人的股份已经被稀释得微不足道了。我们还需要包含一个条件`action`：

```js
{
    kind: 9, // 表示对应地址的投票权和受益权必须在一定比例之上时，交易才能生效
    address: 'xxxxxxxxxxxxx',
    targetAddress: 'ooooooooooooo',
    rightPercent: 20, // 收益权%比例
    votePercent: 18, // 投票权%比例
}
```

此条件`action`排序在第三位，表示完成了上述注资和分股操作后，最终的股权比例要求不低于20%。

### 5. 支付类别

为适应现代金融支付的需要，我们应该支持基于UTXO和余额两种类别的多个支付方式，并且完全考虑到将来会出现一些支付服务商的角色，将提供的支付类型例如：

    1. 自己支付给对方
    2. 请求对方支付给自己（需要对方签名此笔交易）
    3. 让甲支付给乙，而自己只是付出交易费用（需要甲签名）
    4. 让 inputs 内各自指定的资金，支付给 outputs（需要inputs所有人签名）
    5. 让 inputs 内包含的所有资金，支付给 outputs（需要inputs所有人签名）

对于股权账户来说，将有一些特殊的资产变更操作：

    1. 将指定金额按收益权比例分配给所有成员（股份分红）
    2. 将指定金额按投票权分配给持票人（管理层激励）

更多支付方式和数据结构细节将在`附录`给出。

### 6. 签名剥离

由于复杂的支付方式和股权控制体系的存在，一笔交易将包含大量的签名，一个区块甚至可能一半以上都是签名数据，为了节省空间和方便其他交易验证者快速同步数据，签名数据必须设计成可剥离的。

从技术上说，签名列表（包含多签和复合签）内的数据和顺序，不计算入最终交易的hash值。如此就能将交易的核心数据与签名数据分开储存或传输。

剥离后也能让一笔交易的多方参与者互不依赖地并行签名，有利于在商业行为中独立做出决策。

### 7. 手续费

考虑到大规模商业支付的需要，一些服务商会为顾客代理支付并免去交易确认手续费用，也可能出现一些打包或混搅的支付服务，应该将手续费支付方和普通交易参与方签名分隔。

具体在技术层面则是： 一笔交易仅包含一个手续费支付方式，他所签名的原始交易数据中包含 `fee` 字段，而其他人的签名则不包含手续费相关信息，只对自己的交易行为签署确认。

由于主网的交易费用始终处于不停的涨落状态，手续费支出方则可以随时调整费用并重新签名交易，从而取得一个更加经济适合的交易确认时间，并且无需麻烦每一个参与方多次重签。

对于交易确认者（矿工）来说，交易的唯一hash不包含手续费字段，能够剔除重复提交的交易，达到费用动态竞价的效果。

### 8. 字段格式

一个成熟的交易支付系统应该适应未来长期的需要，金额的表示方法及能够保留几乎无限的精度，又能够尽量节省空间：

```js
{
    bill: {
        dict: 1, // 表示资金正负，和amount的空间大小
        amount: Buffer.alloc(), // 数额数量
        unit: 248, // 单位，代表amount后有几个零
    }
}
```
而对于手续费等数据来说，却没那么高的精度需求：

```js
{
    fee: {
        amount: 1234, // 金额
        unit: 240, // 单位，十进制
    },
}
```

其他详细的字段格式及解释将在【附录】给出。


* gotolab：股权控制体系很复杂，会不会影响“货币性”的美感？

第五章、激励
---

一个经济系统能够长时间良好运转的理由很简单：1.让付出创造力和改善效率的人多挣钱；2.避免不劳而获。一切经济优势，都是规则优势，归根到底是制度优势。

一些学院派货币理论认为，货币是中性的，是一个可以被代入抵消的常量，并基于此谬误假设，放弃解答一个真实世界里几乎是最重要的问题：谁应该最先拥有货币？

货币要么本身是商品，要么是商品的代表。正如无法换取商品的货币不能成立一样，也不存在没有产权的商品。产权体系和市场经济是同一个事物的两面，没有清晰产权就不会有真实市场，公正和效率也是同一事物的两面，没有公正就没有效率。

产权的公正性是一切经济效率的前提。加密货币并不绝对公正，但它能极大促进这种公正。

* gotolab：对的，比特币就是这样说的。

### 1. 记账权竞争奖励

维护公共账本的正确和统一是电子货币系统中最重要的工作，我们应该给予足够的奖励。比特币创造性的将竞争记账与货币发行结合起来，成为系统有效运转的引擎。

我们设定每5分钟更新一次账本（产生一个包含新交易列表的区块，由特定哈希算法不断尝试直到找出满足难度要求的数据，称为 `Proof of Work` ，产生后立即广播给所有其他人），新区块内的第一笔交易产生一定数量的新货币，奖励给抢先计算出目标数据的账本验证者自己（简称矿工），其他验证者收到并检查新产生的区块其中的转账数额和签名是否正确，并在此区块后面重新开始计算，试图找出下一个满足难度的区块哈希数据并获得奖励。所有人都会通过计算一段时间内产生的区块数量自动调整目标难度值，以保证在计算能力变化时总能平均5分钟更新一次账本。

产生新货币的数量第一阶段每年调整一次，从1上升至13,；第二阶段每十年调整一次，从13下降至1，第三阶段为永久稳定在1个产出。76年后货币数量在3500万。详细的货币增发算法将在`第六章`给出。

gotolab：注意，这里有一个通胀倍增的设计，前13年通胀率上升，这是一个特色。

### 2. 公账手续费

激励竞争记账产生新区块的同时，还需要鼓励区块中包含尽可能多的有效交易，否则账本系统就是在空转浪费资源。一笔交易需要包含一定量的手续费，由记录交易并产生区块的矿工获得，费用数量采用动态竞价机制。

并且，由于所有交易要让所有矿工验证，公共账本的记录能力和空间大小总是稀缺的。除了愿意付出的价格，我们无法准确判断交易的紧迫性和价值高低。支付更高手续费即能优先得到处理，是相对更有效率的识别方式。

gotolab：手续费原理与比特币一致。

### 3. 通道服务费

我们在`第三章`详述了通道链结算网络，并设想将会出现专门提供资金流转和支付服务的节点出现。节点收取的服务费数量取决于同业竞价、硬件网络费用和通道资金成本。

### 4. 通道利息

类似电话线路和互联网，足够数量的通道组成覆盖性网络，整个体系才能发挥最大的价值。需要鼓励大家将暂时用不到的多余货币放入通道中提供结算服务。

由于开启通道也要像普通交易一样支付确认手续费，我们设定按比例产生极少量的新货币奖励给锁定资金的通道双方，以冲抵其手续费损失。通过有限精度的数据格式（省略零头），让大资金量通道相比小型通道获得奖励更少，以刺激产生更多的通道。由于确认手续费和真实购买支付额度的限制，通道资金规模将保持在一个合适的范围内，不会太巨大，也不会太少。

设定从通道锁定成功开始算起，以双方锁定的总资金为基数，每 2500 个区块（约 8 天，不足则忽略）按复利结算一次利息，利率为万分之一，年利率即为大约 0.42% 。在终止通道产生新货币，按双方开启和结束通道时拥有资金的平均值按比例兑付。

* gotolab：通道利息应该是市场化的，而不应该是固化的设计。否则与PoS无异。

### 5. 区块钻石

只存在于理论中的理想货币：无交易成本、总量随社会总财富的增长与消耗而实时变化。类似一种储量无限的虚拟黄金，当生产力提升时就挖掘出更多铸造成货币流通，生产力降低时由于挖掘成本而自动减少产量。如此就能避免货币剧变导致的通胀或通缩对经济体的伤害。艰难的是我们不得不面对现实的残酷和恶劣，永远达不到理论中的完美。

记账奖励和通道利息的产出数量都是固定的，不会随着生产力变化。我们需要一种能适应人口及技术周期涨落而自动调节产出的货币增长机制，当算力增加时产生更多的新币，并且其挖掘难度只会提升不会下降，以便在算力大幅降低时立即减少或终止新货币的产出。

我们约定区块钻石是一种由32位哈希值经过压缩计算而满足特定格式的一串数据，每个区块最多只能包含一颗钻石（也可以不包含，视算力而定），其生产算法为：

    hash256((genesis_block_hash || prev_diamond_block_hash ) + belong_user_public_key + nonce_number) ==> length_16_string

具体是将 创世区块哈希 或 上一个包含钻石的区块哈希 加上 目标所属者的公钥 加上 任意随机数 进行哈希运算，得到一个64位字符串值，类似：

    35534631f31dfcf12200cdbad65c66ffb9d3fbd3ac985aa8a401bc4c3616bab3

将上一步产生的结果进行特殊的压缩运算，每4位映射到字符列表 `0WTYUIAHXVMEKBSZN` 中，得到如下的16位字符串结果：

    0NMSAK0ZYNSNBAZM  、 00000000IXVKHNHZ  或  0000000000UKNWTH

当结果满足至少前十位为0时且后几位不包含0时，即产生了一颗钻石。根据以上结果，我们称此颗钻石的字面量（标识符）为`UKNWTH`，且字面量唯一不重复。此时将这颗钻石打包进区块并广播，所有钻石生产者停止之前的计算，而采用此新区块的哈希值重新开始计算下一颗钻石的字面值。如果同一区块时间内产生多颗钻石，则由矿工决定打包哪一颗进区块（也许是给出手续费最高的）。

钻石的总量上限约1700万颗。每挖出一颗则整体挖掘难度将相应提高，随着采掘数量的增长成指数级上升，并最终趋近于无限大。

区块钻石是一种异质高维形态的货币，能够达到动态调节货币供应的效果。其价值由挖掘成本及市场公认而定。

* gotolab：双挖设计是特色。这个“钻石”的稀缺性可以吸引矿工，但使整个经济模型也进一步复杂化。

### 6. 数据服务

除了以上描述的系统内部的奖励机制以外，我们还需要一些专门的数据计算商家提供的相关服务，他们将以此收取一些服务费用，例如：

    1. 通道路由
    2. 交易混搅打包
    3. 交易确认查询
    4. 通道恶意终止监控
    5. 加密私钥托管
    6. 信用审计
    7. 数据安全审查

并且将可能产生交易签名机等用于通道链结算网络的专用硬件设备。

* gotolab：太复杂。这些作为二层技术，可以随意叠加，但底层应该长期稳定。

第六章、货币
---

最强大的技术始终要致力于满足最迫切的需求和解决最严重的问题。广义分布式公共账本技术如果无法首先改革世界货币体系以减少对金融弱势群体的掠夺、压迫和剥削，则遑论其他。

### 1. 总量及增长

在长期来看（静态均衡而非短期炒作），除去使用价值方面的影响，如果一种资产会鼓励囤积，那么它的升值率必须大于社会平均生产利润率，否则大家还是会将其拿去投资。而总量恒定的资产的升值率刚好等于社会生产率，那么只需引入少量的增发预期就不会抑制投资和消费。通缩陷阱的破坏力只会在强迫大家使用唯一一种货币并且由于通胀而借贷了巨量债务时才会出现。通胀还会逼迫穷人进行投资，由于不具备信息优势和风险不分散，从而被掠夺更多。

不像纸币或黄金，加密货币一旦遗失则不可能找回。总量若是恒定不变，长期来看将导致过度囤积和投机泡沫，从而损害其作为货币的核心职能。我们需要引入一个通胀预期来避免上述问题，哪怕实际的货币增发量并没有超过现实的经济增长率而不会真的贬值。

由于理论上不可能完全匹配经济交易规模的变化而精准调节流通货币供应（社会每多生产1单位的商品就增发1单位的货币只是一种美好的幻觉），我们只能尽量避免货币量级变动对经济活动的干扰。相对更可行的做法是给出一个可观测的增发预期，让所有人都能估算出一定时间内的货币增长量，配合市场价格指数和购买力指数，通过会计调整后合理安排消费、生产和销售活动。例如在货币购买力持续上升的情况下，只要升值率是稳定可预估的，那么企业发放的工资数额将随时间按比例降低而不是保持不变。工作者也可以接受这种方式，因为因为合约的选择受制于具体资产价格变动的局限条件。他也知道实际能买到的东西并没有减少，只不过长期以来的通胀让人们习惯于工资数额只涨不跌。

#### 1) 记账奖励

我们采用斐波那契数列决定区块的货币奖励发放。第一阶段，每 10 万个区块约 0.95 年调整一次数量，奖励逐渐上升；第二阶段，每 100 万个区块约 9.5 年调整一次数量，奖励逐渐下降；第三阶段，最终恒定在每区块奖励1个单位：

    1, 1, 2, 3, 5, 8, 8(十年), 5(十年), 3(十年), 2(十年), 1(十年), 1(十年), 1, 1, 1, 1, 1 ....

则前 66 年的总供应量为 2200 万单位：

    (1 + 1 + 2 + 3 + 5 + 8 + 8*10 + 5*10 + 3*10 + 2*10 + 1*10 + 1*10 ) * 100000 = 22000000

此后的年增发比例 `(1*100000)/0.95/22000000` 约为 0.4785%，此后逐年递减（100年后约为0.3289%，200年后约0.2506%，500年后约为0.1462%），并无限趋近于零。

#### 2) 通道利息

为促成通道链结算网络的大规模应用，我们设定以 2500 个区块约 8 天为一个结算周期，按复利奖励锁定在通道内的资金，比率为 0.01 % 。假定通道资金占总量的 1/2 ，得出年增发率约为：

    (1+(0.0001*1/2)) ^ (365/(2500/12/24)) ≈ 1.0021  ( 0.21% )

加上记账奖励，平缓时期总的年均增发量粗略估计为 0.6885% ，并无限收敛至约 0.21% 。一个仅供参考的数据是1960年至2012年世界总平均GDP增长率大约为2%~4%。

#### 3) 钻石采掘

钻石的字面值由 `WTYUIAHXVMEKBSZN` 16个字符组成，最终计算出的哈希值后6位为字母则是合法的字面值。其总数量为：

    16^6 = 16777216

我们设定每5个区块约25分钟方能采掘一颗钻石，不考虑难度陡增，要挖掘出所有钻石至少需要：

    16777216*5*5 / (60*24*365) ≈ 800 年

其中每天最多可挖出 `60*24 / (5*5)` 约 58 颗，每年最多出产大约 21000 颗。区块钻石是生产盈余的累积，是经济系统的财富仓库。

### 2. 无限分割

加密货币想要真正应用于商业支付领域，而不是像黄金一样成为收藏品，则必须满足能大规模安全实时交易结算、增量出产稳定及可无限分割。

无限分割保证无论经济发展到何等规模体量，始终能够进行小额支付。数字加密货币应该完全规避传统货币的实体形态所造成的交易费用问题。

### 3. 单位及符号

我们采用一种特殊的类似科学计数法的数据结构来储存资金数额：

```js
bill: {
    //   1 byte, 0~255, 单位（后面跟了几个零）
    unit: 248,
    //   1 byte 表示所占空间及正负， 1~127为正 128~255为负
    dist: 1,
    //   1~127 byte 转账金额数量
    amount: Buffer.alloc(),
}
```

其中 `unit` 表示十进制的单位，比如 `{amount: 1, unit: 4}` 表示 1000， `{amount: 137, unit: 8}` 表示 13700000000。

我们设定 unit=248 时为1`枚`货币，并以1亿为进制，1`枚` = 1亿`铢`，以此类推设立五个单位：

    1. unit:248 为 1枚 = 10^8铢
    2. unit:240 为 1铢 = 10^8烁
    3. unit:232 为 1烁 = 10^8埃
    4. unit:224 为 1埃 = 10^8渺
    5. unit:216 为 1渺

在日常记账中，可将 `273.58铢` 记为 `ㄜ273.58:240` ，而 `1枚` 记为 `ㄜ1:248` 。

引入unit单位意味着，我们可以将一枚货币分割成 1亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿亿 分之一（10^248），而可观测宇宙中原子数量级约为 10^80 个。

### 4. 禁止人为货币政策

货币不应该用来调控经济，这是一种懒惰，并且太危险了。

现代商业经济生态系统越发复杂，已经从稀树草地向亚马逊雨林发展，而采用货币政策调节经济类似于用降水量调控雨林的生长。草地只要有水就能繁荣，而雨林的形成则需要太多的条件和时间，事情并没有看起来这么简单。健康的经济生态只能在合适的条件下生长和进化，而无法被精确设计出来。

人们总是对自己过分自信，但却又无法理解某些复杂系统的涌现规律不能完全被解构建模。加密货币的出现并不是为了取代法币，而是要在一个全新的地方创造全新的金融规则和商业模式。将传统货币金融系统的顽疾硬套在加密货币体系上是无的放矢。金融和经济规则长期从来都是被强势利益集团所裹挟，我们需要为金融弱势群体而抗争，保护勤劳工作的果实不被肆意欺诈篡取。值得注意的是，大规模长时间的货币政策调控的最终受益者一定是离钱和权最近的人，这就会导致贫富差距不可避免的拉大，穷人将在贫穷的泥潭中越陷越深，以至于完全无法凭自己的努力跳出陷阱。人们此时就会期待一个更强有力的政府来进行强制再次分配，社会文化和经济生产将跌到谷底甚至倒退十数年，最终将导向灾难性的人间悲剧。

让某些掌握大量话语权的人或组织投票商议来改变货币体系的核心价值参数的行为和想法是非常愚蠢的，例如修改货币增发的算法、数量或速度。这不是一种类似于宗教原教旨主义的自负行为，而是未来货币系统的关键就在于向大家提供一个不可操控的稳定预期。如果在某些核心价值参数上的设置极不合理或不适应，那就让更好的来取代。


第七章、隐私
---

似乎有些人无法理解，我们行事光明，但还是不愿让人知晓。最大的问题是，窃取消费数据的商家会分析历史购买行为，从而为每一个人给出一个高到刚好能接受的价格，这将极大的损害我们的利益，如果提供的产品是垄断的，后果可想而知。

### 1. 匿名

在公共账本之中，匿名其实是一种假名，并不能始终保持隐匿。由于在某些环节我们总要主动或被迫亮明身份，那么实际上就可通过追溯整个转账链条，暴露所有隐私。匿名地址只是基础，我们需要另一些措施，能够切断支付与收款账户之间的直接联系，从而避免被追踪。

### 2. 支付混搅

通常的转账交易中，付出与收款一一对应，是一个人对另一个人发起支付，而且公开广播，这样很容易推断出两者之间的必然联系。

一个可行的解决方案是，由一群人向另一群人共同发起相同数额的转账，这样就无法将收款方与支付方精确匹配起来，参与转账的人数越多则隐私保护的效果越好，称为定额支付混搅。其交易结构大概为：

```js
{
    // 定额支付混搅
    kind: 6,
    fee: { // 每一个地址单独收取的服务手续费，可为零，甚至可为负
        amount: 1234,
        unit: 248,
    },
    bill: { // 统一转账数额
        dist: 1,
        amount: Buffer.alloc(),
        unit: 248,
    },
    addressCount: 100, // 参与混搅地址数量
    inputAddresses: ["1313Rta8Ce99H7N5iKbGq7xp13BbAdQHmD", "..."], // 多个付出地址
    outputAddresses: ["19aqbMhiK6F2s53gNp2ghoT4EezFFPpXuM", "..."], // 多个收款的地址
}
```

这种混搅方式无需依赖环签名等复杂的技术，简单易行，有如下优点：

    1. 能压缩交易数据的大小，提升主网吞度量，节约手续费
    2. 一些隐私需求强烈者可能通过零手续费甚至补贴来吸引足够的混搅参与者，多方共赢
    3. 无需收款方参与签名（离线到账）

相应的，也具备一些缺点：

    1. 转账金额高度统一，难以用于通常的商品购买
    2. 为适应不同体量的转账，需要分成多个整数梯度进行混搅，从而更难集齐足够数量的参与者
    3. 仍然有被追踪的可能，虽然能通过多次混搅将这种概率降到极低

### 3. 前置延期兑付

支付混搅是从“空间”上模糊了资金发送者和收取者之间的直接联系（同时收付而次序打乱），我们需要更多的保证，那就是从“时间”上切断资金的去向，原理是借助中间人立即转出但延期收取资金，从而在一段时间内无法得知交易的最终接收者。

假定付款者为A，中间人为B，最终收款者为C，转账金额为100单位，则基本步骤为：

    1. B 创造一笔向 C 转账 100 单位的交易 trs1， 将其发送给 A 
    2. A 收到交易 trs1 后，创造一笔特殊交易 trs2 将 101 单位（包含1单位的手续费） 资金发送到一个加密的临时地址 addrx，其中规定了在 trs1 生效一段时间后才能由 B 从临时地址内领取出 101 单位的资金，并将 trs2 展示给 B ，使 B 可以确保资金的安全
    4. A 将 trs2 签署，并广播至主网并确认生效
    5. B 将 trs1 签署，并广播至主网并确认生效，C 收到了 100 单位资金并立即可用
    6. 一段时间后（例如6个月），B 发起一笔交易 trs3 从临时加密地址 addrx 中取出 101 单位资金，整体交易完成

以上方法由于资金的发送和收取有先后顺序，隐含了一个安全风险：A 将资金发送到加密地址，但 B 却由于私钥丢失而不能签署 trs1 交易，实际上导致 A 丢失了 101 单位的资金。

需要注意的是 B 并不存在蓄意不签署的利益动机，因为 B 完成整个交易能获取相应的手续费，就算 B 账户余额不足仍然可以向朋友借贷，待取回资金和手续费后立即返还。有两种情况可能触发丢失：1. B秘钥丢失或因不可抗力无法签署；2.B单纯
